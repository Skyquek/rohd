# Content

- What is ROHD Module?
- First module (one input, one output, simple logic)
- Converting to SystemVerilog
- Exercise 1: Full Adder Module
- Composing modules within other modules
- Port

## Learning Outcome

In this chapter:

- You learn what is ROHD module and how to create a ROHD module. We will be creating a Full Adder ROHD module.

## What is ROHD Module?

If you have prior experience with System Verilog, they are kind of the same `Module` that we are referring. Some would ask why do we need a Module? We had seen in the previous tutorials that we can survive or use ROHD without creating module right? Well, this is because you haven't go deep into simulator or system verilog code generation. 

But in a typical ROHD framework, you will need Module to unlock capability of generateSynth() or Simulation(). Therefore, it is good to learn about ROHD module to further increase the flexibility of the hardware design. We will be using a lot of .build() function in the later Sequential circuit.

In ROHD, `Module` has inputs and outputs that connects them. However, there are severals rules that **MUST** be followed.

1. All logic within a `Module` must consume only inputs (from the `inputs` or `addInput` methods) to the Module directly or indirectly.

2. Any logic outside of a Module must consume the signals only via outputs (from the output or addOutput methods) of the Module.

3. Logic must be defined *before* the call to `super.build()`, which always must be called **at the end of the `build()` method** if it is overidden.

The `Module` base class has an optional String argument 'name' which is an instance name.

## First Module (One input, One output, Simple Logic)

Let say an example of how to create a simple ROHD module. The example below shows the simple module created with **one** `input` and `output`. Notice that `addInput()` and `addOutput()` is used as mentioned previously to register for input and output ports. Another things to note this the Logic of the Module output <= input is included inside the constructor so that build() instruction will pick up the Logic during the execution process.

```dart
import 'package:rohd/rohd.dart';
import 'package:test/test.dart';

class SimpleModule extends Module {
    // constructor
    SimpleModule(Logic input) {
        // register input port
        // add inputs in the constructor, passing in the Logic it is connected to
        // it's a good idea to re-set the input parameters so you don't accidentally use the wrong one
        input = addInput('input_1', input);

        // register output port
        // add outputs in the constructor as well
        // you can capture the output variable to a local variable for use
        var output = addOutput('out');

        // now you can define your logic
        // this example is just a passthrough from 'input' to 'output'
        output <= input;
  }
}

void main() async {
  final input = Const(1);
  final simModule = SimpleModule(input);
  await simModule.build();

  test('should return input value',
      () => expect(simModule.signals.first.value.toInt(), equals(1)));
}
```

Do note that the `build()` method returns a `Future<void>`, not just `void`. This is because the `build()` method is permitted to consume real wallclock time in some cases, for example for setting up cosimulation with another simulator. If you expect your build to consume wallclock time, make sure the Simulator is aware it needs to wait before proceeding.

That all about the basic of the module!

## Converting ROHD Module to System Verilog RTL

Next, we can see how by extending your `Logic` to `Module` enable generation of system verilog code. Consider the example just now, we slightly made some modification by adding `simModule.build()` and `simModule.generateSynth()`.

```dart
void main() async {
    final input = Const(1);
    final simModule = SimpleModule(input);
    await simModule.build();

    // Print out system verilog code
    print(simModule.generateSynth());

    test('should return input value.',
          () => expect(simModule.signals.first.value.toInt(), equals(1)));

    // Add this to generate system verilog code
    test(
          'should generate system verilog code.',
        () => expect(simModule.generateSynth(), contains('module SimpleModule(')));
}
```

The output of the print above will show:

```dart
/**
 * Generated by ROHD - www.github.com/intel/rohd
 * Generation time: 2022-12-29 14:53:52.400586
 * ROHD Version: 0.4.1
 */

module SimpleModule(
input logic input_1,
output logic out
);
assign out = input_1;
endmodule : SimpleModule
```

## Exercise 1

1. Do you still remember how to create a full adder? Now, try to create ROHD Module full adder like above example. If you forgot how to create a full-adder, you can revise back at [chapter 3](../chapter_3/00_unit_test.md).

- Answer to this exercise can be found at [answers/full_adder.dart](./answers/full_adder.dart).

## Composing modules withon other modules

Now, you full-adder is constructed as a module. Let us try to build a N-Bit Adder module now. It's goign to feel like what we had done in the basic generation. To recap, N-Bit Adder is compose of several Adders together. If you forget what is N-Bit adder, you can refer back to tutorial [chapter 4](../chapter_4/00_basic_generation.md).

As you notice in my `FullAdder` and `NBitAdder` class. The `FullAdder` Module class is compose in `FullAdder` class which make the for loop in `NBitAdder` to generate `FullAdder` programmatically.

```dart
import 'package:rohd/rohd.dart';
import 'package:test/test.dart';

class FullAdderResult {
  final sum = Logic(name: 'sum');
  final cOut = Logic(name: 'c_out');
}

class FullAdder extends Module {
  final fullAdderresult = FullAdderResult();

  // Constructor
  FullAdder({
    required Logic a,
    required Logic b,
    required Logic carryIn,
    super.name = 'full_adder',
  }) {
    // Declare Input Node
    a = addInput('a', a, width: a.width);
    b = addInput('b', b, width: b.width);
    carryIn = addInput('carry_in', carryIn, width: carryIn.width);

    // Declare Output Node
    final carryOut = addOutput('carry_out');
    final sum = addOutput('sum');

    final and1 = carryIn & (a ^ b);
    final and2 = b & a;

    // Use Combinational block
    Combinational([
      sum < (a ^ b) ^ carryIn,
      carryOut < and1 | and2,
    ]);

    fullAdderresult.sum <= output('sum');
    fullAdderresult.cOut <= output('carry_out');
  }

  FullAdderResult get fullAdderRes => fullAdderresult;
}

class NBitAdder extends Module {
  // Add Input and output port
  final sum = <Logic>[];
  Logic carry = Const(0);
  Logic a;
  Logic b;

  NBitAdder(this.a, this.b) {
    // Declare Input Node
    a = addInput('a', a, width: a.width);
    b = addInput('b', b, width: b.width);
    carry = addInput('carry_in', carry, width: carry.width);

    final n = a.width;
    FullAdder? res;

    assert(a.width == b.width, 'a and b should have same width.');

    for (var i = 0; i < n; i++) {
      res = FullAdder(a: a[i], b: b[i], carryIn: carry);

      carry = res.fullAdderRes.cOut;
      sum.add(res.fullAdderRes.sum);
    }

    sum.add(carry);
  }

  LogicValue get sumRes => sum.rswizzle().value;
}

void main() async {
  final a = Logic(name: 'a', width: 8);
  final b = Logic(name: 'b', width: 8);
  final nbitAdder = NBitAdder(a, b);

  await nbitAdder.build();

  // print(nbitAdder.generateSynth());

  test('should return 20 when A and B perform add.', () async {
    a.put(15);
    b.put(5);

    expect(nbitAdder.sumRes.toInt(), equals(20));
  });
}
```

Alright, that all for ROHD module. In next session we will be walk through Combinational Logic! Stay tuned!